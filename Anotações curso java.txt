Cap 7 - Principais meotods de string

Formatar: toLowerCase(), toUpperCase(), trim() 
Recortar: substring(inicio), substring(inicio, fim)   - Recorta uma string definindo inicio e fim ou so inicio
Substituir: Replace(char, char), Replace(string, string) - troca uma letra ou uma string por outra
Buscar: IndexOf, LastIndexOf  - buscar o indice por uma string/char ou a ultimo indice daquela string/char
str.Split(" ") - Pega uma string e divide em array por um separador definido no argumento
String.format("%.2f",string)
f
------------------------------------------------------------------------------
CAP 10 - Comportamento de memoria,arrays,list
Classes primitivas precisam ser iniciaadas na sua declaração (nao aceitam null)
Classes derivadas quando iniciadas(ficam na stack) e criam uma referencia para a "caixa"(heap), se nao iniciadas o javax
atribui 0 para numeros, false para booleanos e null para objetos(String por exemplo).
Objetos alocados dinamicamente(heap),quando n possuem mais referencia para eles, serao desalocados pelo gargbage collector.

Vetor = estrutura de dados do mesmo tipo, ordenado, alocado com tamanho fixo.
Double[] vetor; // declaração
vetor = new double[3]; // atribuição

Array de objeto:
Produto[] arrayProduto = new Produto[3]
Quando for peccorer o array de produto, precisa instancia o produto, se n vai dar null pointer

Lista de objetos:
Homogenea, inicia vazia, cade elemento ocupa um no e aponta para o proximo, facil para inserir e remover dados.
List é uma interface é precisa ser instanciada por uma classe que implementa essa interface(array list, linkedlist e etc), nao aceita primitivos.

Operações com listas:
size(): retorna tamanho da listas
remove(objt) / remove(posicao): Remove um elemento se o objeto for igual ou remove pela posição passada
removeIf(Predicate): list.removeIf(x -> x.charAt(0) == 'M' );
add(obj): adiciona um elemento; add(int,obj)
indexOf(obj): encontra posição do elemento;lastOf(obj) encontra posição da ultima incidencia; quando o indexOf nao acha elemento retorna -1
Filtrar lista com predicados: List<Integer> result = list.stream.filter(x -> x>4).collect(Collectors.toList());
Filtrar lista com stream(Aceita operações com expressao lambda = List<Stream> result = list.stream().filter(x -> x.charAt(0) == 'A').collect(Collectors.toList();

Boxing é quando vc pega uma variavel primitiva(stack) e manda pra uma variavel referencia(heap) => int x=20;   Objetc object = x;
Unboxing é quando atribui um variavel tipo referencia(Objetct) a um tipo primitivo  => x = (int)object;
Wrrapers sao classes equivalente aos tipos primitivos = aceitam null, e fazem boxing e unboxing sem precisar fazer cast

------------------------------------------------------------------------------------------------------------
11- GIT

git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/lucashmm94/curso-java.git
git push -u origin master

Configurando email

git config --list        //Lista oq o git tem configurado no pc
 git config --global user.name "Lucas Hermont"  //configura o usuario 
 git config --global user.email "acenelio@gmail.com  //configura o email usado
 
git log --oneline - Mostra as versoes(commits) de uma forma resumida

git clean -df        +    
git checkout -- .      // desfaz tudo que vc fez desde o ultimo commit

git reset --soft HEAD~1  //Remove o ultimo commit, mantendo os arquivos do jeito q estao(O 1 indica q é um commit anterior)
git reset --hard HEAD~1   // Remove o ultimo commit e deixa os arquivos do jeito do ultimo commit(O 1 indica q é um commit anterior)

git push -f origin HEAD^:master  //Remove o ultimo commit no origin

git checkout <código do commit>  // Mostra os arquivos no estado que estava no commit selecionado, exemplo: git checkout e8a52f3

git remote set-url origin https://github.com/acenelio/novoprojeto.git   //Seta seu repositorio local para um nov repositorio

----------------------------------------------------------------------------------------
Cap 14 - Herança e poliformismo

Em uml, classe abstrata tem nome itálico

Um classe abstrata pode ou nao ter metodos abstratos

Se a classe tem um metodo abstrado a classe é abstrata


-------------------------------------------------------------------------------------
Cap 24 - Mapeamento objeto-relacional com JPA/ Hibernate

Sempre usar o javax nas importações

EntityManager - Um objeto EntityManager encapsula uma conexão com a base de dados e serve para efetuar operações de acesso a dados (inserção, remoção, deleção, atualização) em entidades (clientes, produtos, pedidos, etc.) por ele monitoradas em um mesmo contexto de persistência. 
 Escopo: tipicamente mantem-se uma instância única de EntityManager para cada thread do sistema (no caso de aplicações web, para cada requisição ao sistema).  
 
EntityManagerFactory - Um objeto EntityManagerFactory é utilizado para instanciar objetos EntityManager. 
Escopo: tipicamente mantem-se uma instância única de EntityManagerFactory para toda aplicação. 
 
 
a - Para usar o jpa para gravar no banco precisamos instanciar uma fabrica de de entite manager:
EntityManagerFactory emf = Persistence.createEntityManagerFactory("nome-persiste");

b- a fabrica cria uma instancia de entitymanager:
EntityManagerFactory emf = Persistence.createEntityManagerFactory("exemplo-jpa");

c - Para salvar, deletar ou atualiza é preciso inicar uma transação e depois fechar:
em.getTransaction().begin();
emf.close();

d- Para persistir uma informação o metodo é entity manager.persist e se passa o objeto como parametro:
em.persist(p1);

e - para pesquisar se passa a classe e o id:
Pessoa pessoa = em.find(Pessoa.class,2);

f - para deletar:
É preciso pesquisar primeiro e depois deletar:
Pessoa pessoa2 = new Pessoa() //entidade destaca(jpa n consegue remover).
Pessoa pessoa= em.find(Pessoa.class, 2);  //entidade monitorada(jpa so consegue remover esse tipo de objeto)
em.remove(pessoa)


----------------------------------------------------------------------
Cap 15 - Excessao
É qualquer condição de erro ou comportamento encontrada em execução

Exception: O compilador obriga a tratar o erro
RuntimeException: o compilador nao obriga a tratar ou propagar

Bloco finally - É executado independetemente se caiu no try ou catch. Serve para fechar um aruiqvo, conexao com banco.


Converter milisegundos em dias
TimeUnit.Days.convert(diff, TimeUnit.MILISECONDS);
-----------------------------------------------------------------------
16 - TRabalhando com arquivos

File file = new file("c:\\temp\\in.txt");
Scanner sc = new Scanner(file);

while(sc.hasNextLine()){
	system.out.println(sc.nextLine()); //Ler as linhas do arquivo
}

--INSTANCIA FILE READER E BUFFER READER(MAIS RAPIDO QUE O FILE) PARA LER ARQUIVO
String path = "c:\\temp\\in.txt";
try(BufferedReader br = new BufferedReader(new FileReader(path))) {   //Ja fecha os recurso sem precisa dar br.close();
	String line = br.readLine();    //Verifica se no arquivo tem prox linha
	while (line!= null) {
		System.out.println(line);  //Ler proxima linha
		line = br.readLine();    //Verifica se no arquivo tem prox linha
	}
} catch(IOException e){
	system.out.println("Error: " + e.getMessage());
}


File write = para escrever um arquivo

new fileWrite(path)  - Cria ou recria o arquivo(perdendo tudo)
new fileWrite(path, true) - Acrescenta informação em um arquivo ja existente

Buffered Write é mais rapido;

String[] lines = new String[] { "Good morning", "Good afternoon", "Good night" };
String path = "C:\\temp\\out.txt";
try (BufferedWriter bw = new BufferedWriter(new FileWriter(path))) {   //cria o arquivo passado no path
	for (String line : lines) {
		bw.write(line); //escreve na linha
		bw.newLine();
	}
} catch (IOException e) {
	e.printStackTrace();
}


--MANIPULANDO ARQUIVOS


Scanner sc = new Scanner(System.in);
System.out.println("Enter a folder path: ");
String strPath = sc.nextLine();
File path = new File(strPath);
File[] folders = path.listFiles(File::isDirectory);
System.out.println("FOLDERS:");
for (File folder : folders) {
	System.out.println(folder);
}
File[] files = path.listFiles(File::isFile);
	System.out.println("FILES:");
for (File file : files) {
	System.out.println(file);
}

--CRIANDO PASTAS
boolean success = new File(strPath + "\\subdir").mkdir(); // CRIA A PASTA
System.out.println("Directory created successfully: " + success);


--PEGANDO NOME DO ARQUIVO

Scanner sc = new Scanner(System.in);
System.out.println("Enter a folder path: ");
String strPath = sc.nextLine();
File path = new File(strPath);
System.out.println("getPath: " + path.getPath());
System.out.println("getParent: " + path.getParent());
System.out.println("getName: " + path.getName());
sc.close();

---------------------------------------------------------------------
Cap 25 - Web Service com spring boot

Adicionar no header da requisição: content-type: application/json

Metodos de classe, tem q ter o get na frente, exemplo: somar vira getSomar(Para o java ee conseguir identificar)

Get retorna 200
@GetMapping
	public ResponseEntity<List<User>> findAll(){
		List<User> list = service.findAll();
		return ResponseEntity.ok().body(list);
	}
	


Criação de usuario retorna 201.
@PostMapping
	public ResponseEntity<User> save (@RequestBody User user){
		user = service.save(user);
		//Cria o caminho de reposta para o created
		URI uri = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
				.buildAndExpand(user.getId()).toUri();
		return ResponseEntity.created(uri).body(user);
// Forma basica		return ResponseEntity.ok().body(user);
	}


Remoção do usuario retorna 204. 

@DeleteMapping("/{id}")
	public ResponseEntity<Void> deleteById(@PathVariable Long id) {
		service.deleteById(id);
		return ResponseEntity.noContent().build();
	}


PARA CAPTURAR EXCEÇÃO, EVOLVE O BLOCO NO TRYCATCH
DENTRO DO CATCH COLOCA RUNTIMEEXCEPTION e.getprintStacktrace e ver qual erro ta dando exatamente.


No mapeamento 1 para 1 = Coloca @onetoone nos dois lados da associação
Um lado fica com @mapsid
no outro dentro do onetoone(mappedby="nome do objeto na outra classe", cascadetype=cascadetype.all)




